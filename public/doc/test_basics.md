###1 Why Write Tests for your Rails Applications?
Rails makes it super easy to write your tests. It starts by producing skeleton test 
code while you are creating your models and controllers.

By simply running your Rails tests you can ensure your code adheres to the desired 
functionality even after some major code refactoring.

Rails tests can also simulate browser requests and thus you can test your 
application's response without having to test it through your browser.

###2 Introduction to Testing
Testing support was woven into the Rails fabric from the beginning. It wasn't 
an "oh! let's bolt on support for running tests because they're new and cool" epiphany.

2.1 Rails Sets up for Testing from the Word Go
Rails creates a test directory for you as soon as you create a Rails 
project using rails new application_name. If you list the contents 
of this directory then you shall see:

	ls -F test
	controllers/    helpers/        mailers/        test_helper.rb
	fixtures/       integration/    models/
	
The **models** directory is meant to hold tests for your models, the **controllers** 
directory is meant to hold tests for your controllers and the **integration** 
directory is meant to hold tests that involve any number of controllers interacting. 
There is also a directory for testing your **mailers** and one for testing **view helpers**.

**Fixtures** are a way of organizing test data; they reside in the fixtures directory.

The `test_helper.rb` file holds the default configuration for your tests.

###2.2 The Test Environment
By default, every Rails application has three environments: development, test, 
and production.

Each environment's configuration can be modified similarly. In this case, we can 
modify our test environment by changing the options found in `config/environments/test.rb`.

Your tests are run under RAILS_ENV=test.

###2.3 Rails meets Minitest
If you remember, we used the rails generate model command in the Getting Started 
with Rails guide. We created our first model, and among other things it created 
test stubs in the test directory:

	$ bin/rails generate model article title:string body:text
	...
	create  app/models/article.rb
	create  test/models/article_test.rb
	create  test/fixtures/articles.yml
	...

The default test stub in test/models/article_test.rb looks like this:

	require 'test_helper'
	 
	class ArticleTest < ActiveSupport::TestCase
	  # test "the truth" do
	  #   assert true
	  # end
	end

	
----


	require 'test_helper'

	class ZombieTest < ActiveSupport::TestCase
	  # test "the truth" do
	  #   assert true
	  # end
	end

A line by line examination of this file will help get you oriented to 
Rails testing code and terminology.

	require 'test_helper'
	
By requiring this file, test_helper.rb the default configuration to 
run our tests is loaded. We will include this with all the tests we 
write, so any methods added to this file are available to all our tests.

	class ArticleTest < ActiveSupport::TestCase

The ArticleTest class defines a test case because it inherits from 
**ActiveSupport::TestCase**. ArticleTest thus has all the methods 
available from ActiveSupport::TestCase. Later in this guide, 
we'll see some of the methods it gives us.

Any method defined within a class inherited from Minitest::Test 
(which is the superclass of ActiveSupport::TestCase) that begins 
with **test_** (case sensitive) is simply called a test. So, methods 
defined as test_password and test_valid_password are legal test 
names and are run automatically when the test case is run.

Rails also adds a `test` method that takes a test name and a block. 
It generates a normal Minitest::Unit test with method names 
prefixed with test_. So you don't have to worry about naming the 
methods, and you can write something like:

	test "the truth" do
	  assert true
	end

Which is approximately the same as writing this:

	def test_the_truth
	  assert true
	end

However only the test macro allows a more readable test name. You can 
still use regular method definitions though.

The method name is generated by replacing spaces with underscores. The 
result does not need to be a valid Ruby identifier though, the name 
may contain punctuation characters etc. That's because in Ruby 
technically any string may be a method name. This may require use 
of `define_method` and `send` calls to function properly, but formally 
there's little restriction on the name.

Next, let's look at our first assertion:

	assert true
	
An assertion is a line of code that evaluates an object (or expression) 
for expected results. For example, an assertion can check:

1. does this value = that value?
2. is this object nil?
3. does this line of code throw an exception?
4. is the user's password greater than 5 characters?

Every test may contain one or more assertions, with no restriction as 
to how many assertions are allowed. Only when all the assertions are 
successful will the test pass.
